/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

    nonpnp.c

Abstract:

    Purpose of this driver is to demonstrate how to write a legacy (NON WDM)
    driver using framework, show how to handle 4 different ioctls -
    METHOD_NEITHER - in particular and also show how to read & write to file
    from KernelMode using Zw functions.

    For a non-framework version of sample on how to handle IOCTLs in driver,
    study src\general\IOCTL in the DDK.

Environment:

    Kernel mode only.

--*/

#include "nonpnp.h"

//
// The trace message header file must be included in a source file
// before any WPP macro calls and after defining a WPP_CONTROL_GUIDS
// macro. During the compilation, WPP scans the source files for
// TraceEvents() calls and builds a .tmh file which stores a unique
// data GUID for each message, the text resource string for each message,
// and the data types of the variables passed in for each message.
// This file is automatically generated and used during post-processing.
//
#include "nonpnp.tmh"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, NonPnpDeviceAdd)
#pragma alloc_text( PAGE, NonPnpEvtDriverContextCleanup)
#pragma alloc_text( PAGE, NonPnpEvtDriverUnload)
#pragma alloc_text( PAGE, NonPnpEvtDeviceIoInCallerContext)
#pragma alloc_text( PAGE, FileEvtIoDeviceControl)
#pragma alloc_text( PAGE, TimerCallback)
#endif // ALLOC_PRAGMA


/*++

Routine Description:
This routine is called by the Operating System to initialize the driver.

It creates the device object, fills in the dispatch entry points and
completes the initialization.

Arguments:
DriverObject - a pointer to the object that represents this device
driver.

RegistryPath - a pointer to our Services key in the registry.

Return Value:
STATUS_SUCCESS if initialized; an error otherwise.

--*/
NTSTATUS DriverEntry(IN OUT PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath) {

    NTSTATUS                       status;
    WDF_DRIVER_CONFIG              config;
    WDFDRIVER                      hDriver;
    PWDFDEVICE_INIT                pInit = NULL;
    WDF_OBJECT_ATTRIBUTES          attributes;

    KdPrint(("Driver Frameworks NONPNP Legacy Driver Example\n"));


    WDF_DRIVER_CONFIG_INIT(
        &config,
        WDF_NO_EVENT_CALLBACK // This is a non-pnp driver.
        );

    //
    // Tell the framework that this is non-pnp driver so that it doesn't
    // set the default AddDevice routine.
    //
    config.DriverInitFlags |= WdfDriverInitNonPnpDriver;

    //
    // NonPnp driver must explicitly register an unload routine for
    // the driver to be unloaded.
    //
    config.EvtDriverUnload = NonPnpEvtDriverUnload;

    //
    // Register a cleanup callback so that we can call WPP_CLEANUP when
    // the framework driver object is deleted during driver unload.
    //
    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
    attributes.EvtCleanupCallback = NonPnpEvtDriverContextCleanup;

    //
    // Create a framework driver object to represent our driver.
    //
    status = WdfDriverCreate(DriverObject,
                            RegistryPath,
                            &attributes,
                            &config,
                            &hDriver);
    if (!NT_SUCCESS(status)) {
        KdPrint (("NonPnp: WdfDriverCreate failed with status 0x%x\n", status));
        return status;
    }

    //
    // Since we are calling WPP_CLEANUP in the DriverContextCleanup
    // callback we should initialize WPP Tracing after WDFDRIVER
    // object is created to ensure that we cleanup WPP properly
    // if we return failure status from DriverEntry. This
    // eliminates the need to call WPP_CLEANUP in every path
    // of DriverEntry.
    //
    WPP_INIT_TRACING( DriverObject, RegistryPath );

    //
    // On Win2K system,  you will experience some delay in getting trace events
    // due to the way the ETW is activated to accept trace messages.
    //
    KdPrint(("NonPnp: DriverEntry: tracing enabled\n"));

    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_INIT,
                   "Driver Frameworks NONPNP Legacy Driver Example");

    //
    //
    // In order to create a control device, we first need to allocate a
    // WDFDEVICE_INIT structure and set all properties.
    //
    pInit = WdfControlDeviceInitAllocate(
                            hDriver,
                            &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R
                            );

    if (pInit == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Call NonPnpDeviceAdd to create a deviceobject to represent our
    // software device.
    //
    status = NonPnpDeviceAdd(hDriver, pInit);
    
    return status;
}

/*++

Routine Description:

Called by the DriverEntry to create a control-device. This call is
responsible for freeing the memory for DeviceInit.

Arguments:

DriverObject - a pointer to the object that represents this device
driver.

DeviceInit - Pointer to a driver-allocated WDFDEVICE_INIT structure.

Return Value:

STATUS_SUCCESS if initialized; an error otherwise.

--*/
NTSTATUS NonPnpDeviceAdd(IN WDFDRIVER Driver, IN PWDFDEVICE_INIT DeviceInit) {

    NTSTATUS status;
    WDF_OBJECT_ATTRIBUTES attributes;
    WDF_IO_QUEUE_CONFIG ioQueueConfig;
    WDFQUEUE queue;
    WDFDEVICE controlDevice;

	WDF_TIMER_CONFIG timer_config;
	WDF_OBJECT_ATTRIBUTES timer_attributes;

    DECLARE_CONST_UNICODE_STRING(ntDeviceName, NTDEVICE_NAME_STRING) ;
    DECLARE_CONST_UNICODE_STRING(symbolicLinkName, SYMBOLIC_NAME_STRING) ;

    UNREFERENCED_PARAMETER( Driver );

    PAGED_CODE();

    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_INIT, "NonPnpDeviceAdd DeviceInit %p\n", DeviceInit);
    //
    // Set exclusive to TRUE so that no more than one app can talk to the
    // control device at any time.
    //
    WdfDeviceInitSetExclusive(DeviceInit, TRUE);

    WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoBuffered);


    status = WdfDeviceInitAssignName(DeviceInit, &ntDeviceName);

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_INIT, "WdfDeviceInitAssignName failed %!STATUS!", status);
        goto End;
    }

    WdfControlDeviceInitSetShutdownNotification(DeviceInit,
                                                NonPnpShutdown,
                                                WdfDeviceShutdown);

    //
    // In order to support METHOD_NEITHER Device controls, or
    // NEITHER device I/O type, we need to register for the
    // EvtDeviceIoInProcessContext callback so that we can handle the request
    // in the calling threads context.
    //
    WdfDeviceInitSetIoInCallerContextCallback(DeviceInit,
                                    NonPnpEvtDeviceIoInCallerContext);

    //
    // Specify the size of device context
    //
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&attributes,
                                    CONTROL_DEVICE_EXTENSION);

    status = WdfDeviceCreate(&DeviceInit,
                             &attributes,
                             &controlDevice);
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_INIT, "WdfDeviceCreate failed %!STATUS!", status);
        goto End;
    }


	WDF_TIMER_CONFIG_INIT(&timer_config, TimerCallback);

	timer_config.Period = 0;

	WDF_OBJECT_ATTRIBUTES_INIT(&timer_attributes);
	WDF_OBJECT_ATTRIBUTES_SET_CONTEXT_TYPE(&timer_attributes, MY_TIMER_CTX);

	timer_attributes.ParentObject = controlDevice;


    //
    // Create a symbolic link for the control object so that usermode can open
    // the device.
    //


    status = WdfDeviceCreateSymbolicLink(controlDevice, &symbolicLinkName);

    if (!NT_SUCCESS(status)) {
        //
        // Control device will be deleted automatically by the framework.
        //
        TraceEvents(TRACE_LEVEL_ERROR, DBG_INIT, "WdfDeviceCreateSymbolicLink failed %!STATUS!", status);
        goto End;
    }

    //
    // Configure a default queue so that requests that are not
    // configure-fowarded using WdfDeviceConfigureRequestDispatching to goto
    // other queues get dispatched here.
    //
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,
                                    WdfIoQueueDispatchSequential);

    ioQueueConfig.EvtIoDeviceControl = FileEvtIoDeviceControl;

    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
    //
    // Since we are using Zw function set execution level to passive so that
    // framework ensures that our Io callbacks called at only passive-level
    // even if the request came in at DISPATCH_LEVEL from another driver.
    //
    //attributes.ExecutionLevel = WdfExecutionLevelPassive;

    //
    // By default, Static Driver Verifier (SDV) displays a warning if it 
    // doesn't find the EvtIoStop callback on a power-managed queue. 
    // The 'assume' below causes SDV to suppress this warning. If the driver 
    // has not explicitly set PowerManaged to WdfFalse, the framework creates
    // power-managed queues when the device is not a filter driver.  Normally 
    // the EvtIoStop is required for power-managed queues, but for this driver
    // it is not needed b/c the driver doesn't hold on to the requests or 
    // forward them to other drivers. This driver completes the requests 
    // directly in the queue's handlers. If the EvtIoStop callback is not 
    // implemented, the framework waits for all driver-owned requests to be
    // done before moving in the Dx/sleep states or before removing the 
    // device, which is the correct behavior for this type of driver.
    // If the requests were taking an indeterminate amount of time to complete,
    // or if the driver forwarded the requests to a lower driver/another stack,
    // the queue should have an EvtIoStop/EvtIoResume.
    //
    __analysis_assume(ioQueueConfig.EvtIoStop != 0);
    status = WdfIoQueueCreate(controlDevice,
                              &ioQueueConfig,
                              &attributes,
                              &queue // pointer to default queue
                              );
    __analysis_assume(ioQueueConfig.EvtIoStop == 0);
    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, DBG_INIT, "WdfIoQueueCreate failed %!STATUS!", status);
        goto End;
    }

	status = WdfTimerCreate(&timer_config, &timer_attributes, &(ControlGetData(controlDevice)->Timer));

	if (!NT_SUCCESS(status)) {
		KdPrint(("NonPnp: WdfTimerCreate failed with status 0x%x\n", status));
		return status;
	}


    //
    // Control devices must notify WDF when they are done initializing.   I/O is
    // rejected until this call is made.
    //
    WdfControlFinishInitializing(controlDevice);

End:
    //
    // If the device is created successfully, framework would clear the
    // DeviceInit value. Otherwise device create must have failed so we
    // should free the memory ourself.
    //
    if (DeviceInit != NULL) {
        WdfDeviceInitFree(DeviceInit);
    }

    return status;

}


/*++
Routine Description:

Called when the driver object is deleted during driver unload.
You can free all the resources created in DriverEntry that are
not automatically freed by the framework.

Arguments:

Driver - Handle to a framework driver object created in DriverEntry

Return Value:

NTSTATUS

--*/
VOID NonPnpEvtDriverContextCleanup(IN WDFOBJECT Driver) {

    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_INIT,
                        "Entered NonPnpEvtDriverContextCleanup\n");

    PAGED_CODE();

    //
    // No need to free the controldevice object explicitly because it will
    // be deleted when the Driver object is deleted due to the default parent
    // child relationship between Driver and ControlDevice.
    //
    WPP_CLEANUP( WdfDriverWdmGetDriverObject( (WDFDRIVER)Driver ) );

}



VOID TimerCallback(IN WDFTIMER timerHandle) {

	PCHAR outBuf = NULL;
	size_t bufSize;

	NTSTATUS status = WdfRequestRetrieveOutputBuffer(getMyTimerCtx(timerHandle)->Request, 0, (PVOID)&outBuf, &bufSize);

	RtlCopyMemory(outBuf, "Hello From WdfTimer!!!", getMyTimerCtx(timerHandle)->OutputBufferLength);
	WdfRequestSetInformation(getMyTimerCtx(timerHandle)->Request, getMyTimerCtx(timerHandle)->OutputBufferLength);

	WdfRequestComplete(getMyTimerCtx(timerHandle)->Request, status);

};

LONGLONG toLONGLONG_my(PCHAR addr);

VOID FileEvtIoDeviceControl(IN WDFQUEUE Queue, IN WDFREQUEST Request, IN size_t OutputBufferLength, IN size_t InputBufferLength, IN ULONG IoControlCode) {

	PCONTROL_DEVICE_EXTENSION devExt = ControlGetData(WdfIoQueueGetDevice(Queue));

	PMY_TIMER_CTX pctx = getMyTimerCtx(devExt->Timer);

	pctx->Request = Request;
	pctx->OutputBufferLength = OutputBufferLength;

	
	PCHAR inBuf = NULL; 
	size_t bufSize;
	ULONG timerDelay; // ms
	UNICODE_STRING ustr;
	ANSI_STRING astr;

	WdfRequestRetrieveInputBuffer(Request, 0, (PVOID)&inBuf, &bufSize);
	RtlInitAnsiString(&astr, inBuf);
	RtlAnsiStringToUnicodeString(&ustr, &astr, TRUE);
	RtlUnicodeStringToInteger(&ustr, 0, &timerDelay);

//	RtlFreeUnicodeString(&ustr);
//	RtlFreeAnsiString(&astr);

	WdfTimerStart(devExt->Timer, WDF_REL_TIMEOUT_IN_MS(timerDelay));

}


/*++
Routine Description:

This I/O in-process callback is called in the calling threads context/address
space before the request is subjected to any framework locking or queueing
scheme based on the device pnp/power or locking attributes set by the
driver. The process context of the calling app is guaranteed as long as
this driver is a top-level driver and no other filter driver is attached
to it.

This callback is only required if you are handling method-neither IOCTLs,
or want to process requests in the context of the calling process.

Driver developers should avoid defining neither IOCTLs and access user
buffers, and use much safer I/O tranfer methods such as buffered I/O
or direct I/O.

Arguments:

Device - Handle to a framework device object.

Request - Handle to a framework request object. Framework calls
PreProcess callback only for Read/Write/ioctls and internal
ioctl requests.

Return Value:

VOID

--*/
VOID NonPnpEvtDeviceIoInCallerContext(IN WDFDEVICE  Device, IN WDFREQUEST Request) {

	NTSTATUS                   status = STATUS_SUCCESS;
	WDF_REQUEST_PARAMETERS  params;
	size_t              inBufLen, outBufLen;
	PVOID              inBuf, outBuf;

	PAGED_CODE();

	WDF_REQUEST_PARAMETERS_INIT(&params);

	WdfRequestGetParameters(Request, &params);

	TraceEvents(TRACE_LEVEL_VERBOSE, DBG_IOCTL, "Entered NonPnpEvtDeviceIoInCallerContext %p \n",
		Request);

	//
	// Check to see whether we have recevied a METHOD_NEITHER IOCTL. if not
	// just send the request back to framework because we aren't doing
	// any pre-processing in the context of the calling thread process.
	//
	if (!(params.Type == WdfRequestTypeDeviceControl && 0)) {
		//
		// Forward it for processing by the I/O package
		//
		status = WdfDeviceEnqueueRequest(Device, Request);
		if (!NT_SUCCESS(status)) {
			TraceEvents(TRACE_LEVEL_ERROR, DBG_IOCTL,
				"Error forwarding Request 0x%x", status);
			goto End;
		}

		return;
	}

	TraceEvents(TRACE_LEVEL_VERBOSE, DBG_IOCTL, "EvtIoPreProcess: received METHOD_NEITHER ioctl \n");

	//
	// In this type of transfer, the I/O manager assigns the user input
	// to Type3InputBuffer and the output buffer to UserBuffer of the Irp.
	// The I/O manager doesn't copy or map the buffers to the kernel
	// buffers.
	//
	status = WdfRequestRetrieveUnsafeUserInputBuffer(Request, 0, &inBuf, &inBufLen);
	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, DBG_IOCTL,
			"Error WdfRequestRetrieveUnsafeUserInputBuffer failed 0x%x", status);
		goto End;
	}

	status = WdfRequestRetrieveUnsafeUserOutputBuffer(Request, 0, &outBuf, &outBufLen);
	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, DBG_IOCTL,
			"Error WdfRequestRetrieveUnsafeUserOutputBuffer failed 0x%x", status);
		goto End;
	}

	//
	// Finally forward it for processing by the I/O package
	//
	status = WdfDeviceEnqueueRequest(Device, Request);
	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, DBG_IOCTL,
			"Error WdfDeviceEnqueueRequest failed 0x%x", status);
		goto End;
	}

	return;

End:

	TraceEvents(TRACE_LEVEL_VERBOSE, DBG_IOCTL, "EvtIoPreProcess failed %x \n", status);
	WdfRequestComplete(Request, status);
	return;
}


/*++

Routine Description:
Callback invoked when the machine is shutting down.  If you register for
a last chance shutdown notification you cannot do the following:
o Call any pageable routines
o Access pageable memory
o Perform any file I/O operations

If you register for a normal shutdown notification, all of these are
available to you.

This function implementation does nothing, but if you had any outstanding
file handles open, this is where you would close them.

Arguments:
Device - The device which registered the notification during init

Return Value:
None

--*/
VOID NonPnpShutdown(WDFDEVICE Device) {

    UNREFERENCED_PARAMETER(Device);
    return;
}

/*++
Routine Description:

Called by the I/O subsystem just before unloading the driver.
You can free the resources created in the DriverEntry either
in this routine or in the EvtDriverContextCleanup callback.

Arguments:

Driver - Handle to a framework driver object created in DriverEntry

Return Value:

NTSTATUS

--*/
VOID NonPnpEvtDriverUnload(IN WDFDRIVER Driver) {

    UNREFERENCED_PARAMETER(Driver);

    PAGED_CODE();

    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_INIT, "Entered NonPnpDriverUnload\n");

    return;
}

VOID PrintChars(_In_reads_(CountChars) PCHAR BufferAddress, _In_ size_t CountChars) {

    if (CountChars) {

        while (CountChars--) {

            if (*BufferAddress > 31
                 && *BufferAddress != 127) {

                KdPrint (( "%c", *BufferAddress) );

            } else {

                KdPrint(( ".") );

            }
            BufferAddress++;
        }
        KdPrint (("\n"));
    }
    return;
}
